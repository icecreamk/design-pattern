### 终端命令
> npm init // 初始化创建package.json

> clear // 清空终端命令行

### 三要素
- 继承：子类继承父类
- 封装：数据的权限和保密  （public完全开放 private对自己开发 protected对自己和*子类开放）es6不支持，typescript支持
- 多态：同一接口不同实现

### 为何面向对象
- 模拟真实的事物
- 程序执行：顺序、判断、循环 --->结构化
- 数据结构化（避免所有变量散乱在全局环境中）

### 设计的作用
- 按照一种思路或标准实现功能
- 功能相同，可能有不同的设计方案来实现
- 伴随需求的增加，设计的作用越来越能体现出来

### 设计原则
- 小即是美
- 让每个程序只做好一件事
- 快速建立原型（满足需求的最简版本，后续再根据需求升级）
- 舍弃高效率而取可移植性（复用性）
- 采用纯文本来存储数据
- 充分利用软件的杠杆效应（软件复用）
- 使用shell脚本来提高杠杆效应和可移植性
- 避免强制性的用户界面
- 让每个程序都称为过滤器
- 允许用户定制环境
- 尽量使操作系统内核小而轻量化
- 使用小写字母并尽量简短
- 沉默是金，无提示是最好的结果（不满足条件则不输出）
- 各部分之和大于整体
- 寻求90%的解决方案（满足90%的客户）

### 5大设计原则
- S 单一职责原则（single）
    + 一个程序只做好一件事
    + 拆分过于复杂功能，每个部分保持独立
    + 注解：通过对职责划分，使代码结构清晰，提高代码可读性，且有效降低程序出错对风险
- O 开放封闭原则（open）
    + 对扩展开放，对修改封闭
    + 增加需求时候，扩展新代码，而非修改已有代码
    + 注解：降低程序维护成本，不改动原有代码，增添新代码，避免大量回归测试
- L 里氏置换原则（Liskov）
    + 子类可以扩展父类对方法，但不能改变父类原有功能
    + 父类能出现的地方子类就能出现替换父类
    + 注解：如果重写父类方法实现新功能，但在后期维护以及继承体系中的可复用性会比较差，程序更会大概率出错
- I 接口独立原则（interface）
    + 保存接口的单一独立，最小单元，避免“胖接口”
    + 类似单一职责原则，此处更关注接口
    + 注解：接口职责需划分明确，避免一个接口包含不同职责的方法
- D 依赖倒置原则（Dependence）
    + 面向接口编程，依赖于抽象而不依赖于具体
    + 关注接口，而不关注具体类实现
    + 注解：高层模块不应该依赖低层模块，都应该依赖抽象

### 设计模式（23种）
#### 写好代码，做好设计
- 创建型
    + 工厂模式（工厂方法模式、抽象工厂模式，建造者模式）
    + 单例模式
    + 原型模式
- 结构性
    + 适配器模式
    + 装饰器模式
    + 代理模式
    + 外观模式
    + 桥接模式
    + 组合模式
    + 享元模式
- 行为型
    + 策略模式
    + 模板方法模式
    + 观察者模式
    + 迭代器模式
    + 职责链模式
    + 命令模式
    + 备忘录模式
    + 状态模式
    + 访问者模式
    + 中介者模式
    + 解释器模式

#### 日常使用
- 常用设计模式，掌握优缺点即它们之间的差异
- 非常用设计模式，视业务场景选择性使用

#### 讲解
- 介绍举例
- UML图，demo代码
- 结合应用场景，讲解如何被使用

#### 学习
- 理解每个设计的用意
- 通过应用场景体会它的真正使用场景
- 编码时多思考，尽量模仿使用